name: Deploy Frontend to Production Environment

on:
  # Manual deployment only - no automatic deployments
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  PULUMI_STACK: prod

jobs:
  deploy:
    runs-on: ubuntu-latest

    # Manual deployment only - no automatic deployments
    if: github.event_name == 'workflow_dispatch'

    concurrency:
      group: deploy-prod-${{ github.ref }}
      cancel-in-progress: false

    permissions:
      id-token: write
      contents: read

    environment:
      name: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.sha }}

      - name: Deployment Trigger Info
        run: |
          echo "=========================================="
          echo "ðŸš€ Production Deployment Triggered"
          echo "=========================================="
          echo "Trigger: Manual dispatch"
          echo "âš ï¸  Manual deployment - ensure tests have passed!"
          echo "=========================================="

      - name: Install uv
        uses: astral-sh/setup-uv@v3
        with:
          version: "latest"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Pulumi dependencies
        working-directory: infrastructure
        run: |
          uv venv
          source .venv/bin/activate
          uv pip install -e ".[dev]"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_PROD_ROLE_ARN || secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Pulumi
        uses: pulumi/actions@v4
        with:
          pulumi-version: latest

      - name: Select Pulumi Stack
        working-directory: infrastructure
        run: |
          source .venv/bin/activate
          pulumi stack select ${{ env.PULUMI_STACK }}
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
          PULUMI_PYTHON_CMD: ${{ github.workspace }}/infrastructure/.venv/bin/python

      - name: Find Elastic Beanstalk Solution Stack
        id: find-solution-stack
        run: |
          echo "Finding available Docker solution stack..."
          SOLUTION_STACK=$(aws elasticbeanstalk list-available-solution-stacks --region ${{ env.AWS_REGION }} \
            --query 'SolutionStacks[?contains(@, `Docker`) && contains(@, `Amazon Linux 2`)] | [0]' \
            --output text)

          if [ -z "$SOLUTION_STACK" ]; then
            echo "âš ï¸ No Amazon Linux 2 Docker stack found, trying Amazon Linux 2023..."
            SOLUTION_STACK=$(aws elasticbeanstalk list-available-solution-stacks --region ${{ env.AWS_REGION }} \
              --query 'SolutionStacks[?contains(@, `Docker`) && contains(@, `Amazon Linux 2023`)] | [0]' \
              --output text)
          fi

          if [ -z "$SOLUTION_STACK" ]; then
            echo "âŒ No Docker solution stack found!"
            echo "Available Docker stacks:"
            aws elasticbeanstalk list-available-solution-stacks --region ${{ env.AWS_REGION }} \
              --query 'SolutionStacks[?contains(@, `Docker`)]' \
              --output table
            exit 1
          fi

          echo "âœ… Found solution stack: $SOLUTION_STACK"
          echo "solution_stack=$SOLUTION_STACK" >> $GITHUB_OUTPUT

          # Set Pulumi config
          cd infrastructure
          source .venv/bin/activate
          pulumi config set --path frontend-infrastructure:ebSolutionStack "$SOLUTION_STACK"
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
          PULUMI_PYTHON_CMD: ${{ github.workspace }}/infrastructure/.venv/bin/python

      - name: Pulumi Preview
        working-directory: infrastructure
        run: |
          source .venv/bin/activate
          pulumi preview --stack ${{ env.PULUMI_STACK }}
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
          PULUMI_PYTHON_CMD: ${{ github.workspace }}/infrastructure/.venv/bin/python

      - name: Refresh Pulumi State
        working-directory: infrastructure
        run: |
          source .venv/bin/activate
          echo "ðŸ”„ Refreshing Pulumi state to detect deleted resources..."
          pulumi refresh --yes --stack ${{ env.PULUMI_STACK }} || true
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
          PULUMI_PYTHON_CMD: ${{ github.workspace }}/infrastructure/.venv/bin/python

      - name: Pulumi Up (Production)
        working-directory: infrastructure
        run: |
          source .venv/bin/activate
          pulumi up --yes --stack ${{ env.PULUMI_STACK }}
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
          PULUMI_PYTHON_CMD: ${{ github.workspace }}/infrastructure/.venv/bin/python

      - name: Get Pulumi outputs
        id: outputs
        working-directory: infrastructure
        run: |
          source .venv/bin/activate
          ECR_REPO_URL=$(pulumi stack output ecr_repository_url --stack ${{ env.PULUMI_STACK }})
          ECR_REPO_NAME=$(pulumi stack output ecr_repository_name --stack ${{ env.PULUMI_STACK }})
          EB_APP_NAME=$(pulumi stack output eb_application_name --stack ${{ env.PULUMI_STACK }})
          EB_ENV_NAME=$(pulumi stack output eb_environment_name --stack ${{ env.PULUMI_STACK }})
          echo "ecr_repo_url=$ECR_REPO_URL" >> $GITHUB_OUTPUT
          echo "ecr_repo_name=$ECR_REPO_NAME" >> $GITHUB_OUTPUT
          echo "eb_app_name=$EB_APP_NAME" >> $GITHUB_OUTPUT
          echo "eb_env_name=$EB_ENV_NAME" >> $GITHUB_OUTPUT
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
          PULUMI_PYTHON_CMD: ${{ github.workspace }}/infrastructure/.venv/bin/python

      - name: Generate Image Tag
        id: image-tag
        run: |
          VERSION=${GITHUB_REF#refs/tags/}
          if [ -z "$VERSION" ] || [ "$VERSION" = "$GITHUB_REF" ]; then
            VERSION=${GITHUB_SHA::8}
          fi
          IMAGE_TAG="$VERSION"
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "Generated image tag: $IMAGE_TAG"

      - name: Verify ECR Repository Exists
        run: |
          ECR_REPO_NAME="${{ steps.outputs.outputs.ecr_repo_name }}"
          AWS_REGION="${{ env.AWS_REGION }}"

          echo "Verifying ECR repository exists: $ECR_REPO_NAME"

          # Check if repository exists
          if aws ecr describe-repositories --repository-names "$ECR_REPO_NAME" --region "$AWS_REGION" &>/dev/null; then
            echo "âœ… ECR repository '$ECR_REPO_NAME' exists"
          else
            echo "âš ï¸  ECR repository '$ECR_REPO_NAME' not found. This should have been created by Pulumi."
            echo "Creating it now as a fallback..."
            aws ecr create-repository \
              --repository-name "$ECR_REPO_NAME" \
              --region "$AWS_REGION" \
              --image-scanning-configuration scanOnPush=true \
              --encryption-configuration encryptionType=AES256
            echo "âœ… ECR repository '$ECR_REPO_NAME' created"
          fi

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push Docker Image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ steps.outputs.outputs.ecr_repo_name }}
          IMAGE_TAG: ${{ steps.image-tag.outputs.image_tag }}
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          echo "Building Docker image with tag: $IMAGE_TAG"
          cd frontend
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .

          # Tag for fallback
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:prod

          echo "Pushing image with tag: $IMAGE_TAG"
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:prod

          echo "âœ… Image built and pushed successfully with tag: $IMAGE_TAG"

      - name: Create Elastic Beanstalk Application Version
        id: create-version
        run: |
          EB_APP_NAME="${{ steps.outputs.outputs.eb_app_name }}"
          EB_ENV_NAME="${{ steps.outputs.outputs.eb_env_name }}"
          ECR_REPO_URL="${{ steps.outputs.outputs.ecr_repo_url }}"
          IMAGE_TAG="${{ steps.image-tag.outputs.image_tag }}"
          AWS_REGION="${{ env.AWS_REGION }}"

          # Create a Dockerrun.aws.json with the ECR image URL
          cat > /tmp/Dockerrun.aws.json << EOF
          {
            "AWSEBDockerrunVersion": "1",
            "Image": {
              "Name": "${ECR_REPO_URL}:${IMAGE_TAG}",
              "Update": "true"
            },
            "Ports": [
              {
                "ContainerPort": "80"
              }
            ]
          }
          EOF

          # Create S3 bucket for EB source bundles (if needed)
          S3_BUCKET="eb-deployments-${AWS_REGION}-$(aws sts get-caller-identity --query Account --output text)"
          aws s3 mb s3://$S3_BUCKET --region $AWS_REGION 2>/dev/null || true

          # Create source bundle
          VERSION_LABEL="v${IMAGE_TAG}-$(date +%s)"
          cd /tmp
          zip -r source-bundle.zip Dockerrun.aws.json
          aws s3 cp source-bundle.zip s3://$S3_BUCKET/source-bundles/$VERSION_LABEL.zip

          # Create application version
          aws elasticbeanstalk create-application-version \
            --application-name "$EB_APP_NAME" \
            --version-label "$VERSION_LABEL" \
            --source-bundle S3Bucket="$S3_BUCKET",S3Key="source-bundles/$VERSION_LABEL.zip" \
            --region "$AWS_REGION"

          echo "version_label=$VERSION_LABEL" >> $GITHUB_OUTPUT
          echo "âœ… Created application version: $VERSION_LABEL"
        env:
          AWS_REGION: ${{ env.AWS_REGION }}

      - name: Deploy to Elastic Beanstalk Environment
        run: |
          EB_APP_NAME="${{ steps.outputs.outputs.eb_app_name }}"
          EB_ENV_NAME="${{ steps.outputs.outputs.eb_env_name }}"
          VERSION_LABEL="${{ steps.create-version.outputs.version_label }}"
          AWS_REGION="${{ env.AWS_REGION }}"

          echo "Deploying version $VERSION_LABEL to environment $EB_ENV_NAME"

          aws elasticbeanstalk update-environment \
            --application-name "$EB_APP_NAME" \
            --environment-name "$EB_ENV_NAME" \
            --version-label "$VERSION_LABEL" \
            --region "$AWS_REGION"

          echo "âœ… Deployment initiated. Environment update in progress..."

      - name: Wait for Deployment
        run: |
          EB_ENV_NAME="${{ steps.outputs.outputs.eb_env_name }}"
          AWS_REGION="${{ env.AWS_REGION }}"

          echo "Waiting for deployment to complete..."
          MAX_WAIT=900  # 15 minutes for production
          ELAPSED=0

          while [ $ELAPSED -lt $MAX_WAIT ]; do
            STATUS=$(aws elasticbeanstalk describe-environments \
              --environment-names "$EB_ENV_NAME" \
              --region "$AWS_REGION" \
              --query 'Environments[0].Status' \
              --output text)
            
            HEALTH=$(aws elasticbeanstalk describe-environments \
              --environment-names "$EB_ENV_NAME" \
              --region "$AWS_REGION" \
              --query 'Environments[0].Health' \
              --output text)
            
            echo "Status: $STATUS, Health: $HEALTH (${ELAPSED}s/${MAX_WAIT}s)"
            
            if [ "$STATUS" = "Ready" ] && [ "$HEALTH" = "Ok" ]; then
              echo "âœ… Deployment completed successfully!"
              break
            elif [ "$STATUS" = "Ready" ] && [ "$HEALTH" != "Ok" ]; then
              echo "âš ï¸ Environment is Ready but Health is $HEALTH"
              break
            fi
            
            sleep 15
            ELAPSED=$((ELAPSED + 15))
          done

          if [ $ELAPSED -ge $MAX_WAIT ]; then
            echo "âš ï¸ Deployment timeout. Check AWS console for status."
            exit 1
          fi

      - name: Get Environment URL
        id: env-url
        run: |
          EB_ENV_NAME="${{ steps.outputs.outputs.eb_env_name }}"
          AWS_REGION="${{ env.AWS_REGION }}"

          ENV_URL=$(aws elasticbeanstalk describe-environments \
            --environment-names "$EB_ENV_NAME" \
            --region "$AWS_REGION" \
            --query 'Environments[0].CNAME' \
            --output text)

          echo "environment_url=$ENV_URL" >> $GITHUB_OUTPUT
          echo "âœ… Environment URL: $ENV_URL"

      - name: Deployment Summary
        run: |
          echo "=========================================="
          echo "âœ… Production Deployment Complete"
          echo "=========================================="
          echo "ECR Repository: ${{ steps.outputs.outputs.ecr_repo_url }}"
          echo "Image Tag: ${{ steps.image-tag.outputs.image_tag }}"
          echo "EB Application: ${{ steps.outputs.outputs.eb_app_name }}"
          echo "EB Environment: ${{ steps.outputs.outputs.eb_env_name }}"
          echo "Environment URL: ${{ steps.env-url.outputs.environment_url }}"
          echo "=========================================="
